import os
import asyncio
from psycopg2 import connect, sql, Error
import psycopg2.extras
import logging
import re
import json

__all__=['encode_fields', 'encode_all']

class SQLit:

    def __init__(self, user=None, password=None, db=None, host=None, port=5432):
        self.log = logging.getLogger(__name__)
        try:
            self.connection = connect(
                connection_factory=psycopg2.extras.LoggingConnection,
                user     = user or os.environ.get('DB_P2STORE_USER', 'postgres'),
                password = password or os.environ.get('DB_P2STORE_PASSWORD'),
                host     = host or os.environ.get('DB_P2STORE_HOST'),
                port     = port or os.environ.get('DB_P2STORE_PORT'),
                database = db or os.environ.get('DB_P2STORE_DBNAME', 'p2store'),
                connect_timeout = 10
                )
            self.connection.initialize(self.log)
        except psycopg2.Error as e:
            self.log.error("Error getting a connection: {}".format(e))
            raise e

    def __del__(self):
        if(self.connection):
            self.connection.close()


    def execute(self, stmt, *data):
        data = encode_all(data)
        self.log.debug(stmt)
        try:
            cursor = self.connection.cursor(cursor_factory = psycopg2.extras.DictCursor)
            cursor.execute(stmt, data)

            if re.search('select', str(stmt), re.IGNORECASE):
                record = cursor.fetchall()
                return(record)
            else:
                self.connection.commit()
                return(cursor.rowcount)
        except (Exception, Error) as error :
            self.log.error(f"Stmt: {stmt}, Data: {data}, Error: {error}")
            raise error

    def execute_as_dict(self, stmt, *data):
        data = encode_all(data)
        self.log.debug("Query: {}, data: {}".format(stmt, data))
        try:
            cursor = self.connection.cursor(cursor_factory = psycopg2.extras.RealDictCursor)
            cursor.execute(stmt, data)
            if re.search('select', str(stmt), re.IGNORECASE):
                record = cursor.fetchall()
                return(record)
            else:
                self.connection.commit()
                return(cursor.rowcount)
        except (Exception, Error) as error :
            self.log.error(f"Stmt: {stmt}, Data: {data}, Error: {error}")
            raise error


    def select( self, table,
            limit: int=None,
            offset: int=None,
            fetch: list=None,
            sort: str=None,
            **filter ):
        """ Returns all records from table that match the filter """

        return self.execute(*(self._build_query(
            table=table,
            limit=limit,
            offset=offset,
            fetch=fetch,
            sort=sort,
            filter=filter)))


    def select_as_dict( self, table,
            limit: int=None,
            offset: int=None,
            fetch: list=None,
            sort: str=None,
            **filter ):
        """ Returns all records from table that match the filter
            or none if filter is not a dict.
        """

        return self.execute_as_dict(*(self._build_query(
            table=table,
            limit=limit,
            offset=offset,
            fetch=fetch,
            sort=sort,
            filter=filter)))


    @staticmethod
    def _add_filter_str(filter_str: str, values, key: str, operator: str=None, value: str=None):
        operator = operator or '='
        if len(filter_str):
            filter_str += " AND "

        if operator in ('in'):
            filter_str += f"{key} {operator} {value}"
        else:
            filter_str += f"{key} {operator} %s"
            values.append(value)
        return (filter_str, values)


    def _build_where_clause(self, filter_str: str, values, key: str, value: str):
        operator = '='
        key_name = key
        tokens=key.split('|')
        if len(tokens) == 2:
            key_name = tokens[0]
            operator = tokens[1]
        if type(value) is list or type(value) is tuple:
            for val in value:
                (filter_str, values) = self._add_filter_str(filter_str, values, key_name, operator, val)
            return (filter_str, values)
        else:
            return self._add_filter_str(filter_str, values, key_name, operator, value)


    def _build_query(self, table: str, limit: int=None, offset: int=None, fetch: list=None,
                     sort: str=None, filter: dict=None ) -> str:

        fetchers = ", ".join(fetch) if fetch else '*'
        values = list()
        if filter:
            filter_str = ""
            for key in sorted(filter.keys()):
                (filter_str, values) = self._build_where_clause(filter_str, values, key, filter[key])

            query = "SELECT {} FROM {} WHERE {}".format(fetchers, table, filter_str)
        else:
            query = "SELECT {} FROM {}".format(fetchers, table)
        if sort:
            query += " ORDER BY {}".format(sort)
        if limit is not None:
            query += " LIMIT %s "
            values.append(limit)
        if offset is not None:
            query += " OFFSET %s"
            values.append(offset)
        return (query, *values)


    def update(self, table, primary_key, primary_key_value, **attrs):
        if primary_key is None:
            self.log.error("Error: no primary key")
            return(None)

        values = list(attrs.values())
        values.append(primary_key_value)
        attrs_str = ", ".join("{} = %s".format(k) for k in attrs.keys())
        query = "UPDATE {} SET {} WHERE {}=%s".format(table, attrs_str, primary_key)
        return self.execute(query, *values)


    def insert_stmt(self, table, record):
        """ insert record into table """
        fields = [field for field in record.keys()]
        placeholders = ['%s' for k in record.keys()]
        stmt = "INSERT INTO {} ({}) VALUES ({})".format(
                table,
                (', ').join(fields),
                (', ').join(placeholders))
        return stmt


    def insert_stmt_returning_id(self, table, record, id):
        """ insert record into table returning current id value
            used to retrieve serial primary keys in 1 round
        """
        fields = [field for field in record.keys()]
        placeholders = ['%s' for k in record.keys()]
        stmt = "INSERT INTO {} ({}) VALUES ({}) RETURNING {};".format(
            table,
            (', ').join(fields),
            (', ').join(placeholders),
            id)
        self.log.debug(stmt)
        return stmt


    def do_insert_or_update(self, table, conflicting_cols, record):
        fields = list(record.keys())
        rec_placeholders = ['%s' for k in record.keys()]
        not_conflicting_cols=list()
        for f in fields:
            if f not in conflicting_cols:
                not_conflicting_cols.append(f)
        not_conflicting_placeholders = ['%s' for col in not_conflicting_cols]
        stmt=""
        if len(not_conflicting_cols) > 1:
            stmt = """
                INSERT INTO {} ({})
                VALUES ({})
                ON CONFLICT ({}) DO UPDATE SET
                ({}) = ({});""".format( 
                    table,
                    (', ').join(fields),
                    (', ').join(rec_placeholders),
                    (', ').join(conflicting_cols),
                    (', ').join(not_conflicting_cols),
                    (', ').join(not_conflicting_placeholders)
                )
        else:
            stmt = """
                INSERT INTO {} ({})
                VALUES ({})
                ON CONFLICT ({}) DO UPDATE SET
                {} = %s;""".format( 
                    table,
                    (', ').join(fields),
                    (', ').join(rec_placeholders),
                    (', ').join(conflicting_cols),
                    not_conflicting_cols[0]
                )
        values = list(record.values()) + [record[k] for k in not_conflicting_cols]
        return self.execute(stmt, *values)


    def delete(self, table, key, value):
        stmt = "DELETE FROM {} WHERE {} = %s".format(table, key)
        return self.execute(stmt, value)


    def add(self, table, **record):
        stmt=self.insert_stmt(table, record)
        return self.execute(stmt, *list(record.values()))


    def add_returning_id(self, table, id, **record):
        try:
            cursor = self.connection.cursor()
            stmt=self.insert_stmt_returning_id(table, record, 'id')
            cursor.execute(stmt, list(record.values()))
            self.connection.commit()
            return(cursor.fetchone()[0])
        except Exception as e:
            self.log.error(f"Stmt: {stmt}, values: {list(record.values())}, error: {e}")
            raise e


    def add_or_update(self, table, key, key_value, **record):
        """ Looks for a record pointed by filter in table is found
            it is updated, otherwise inserted.
            Returns the record updated or inserted on None in case
            of error.
        """
        try:
            with self.connection as conn:
                with conn.cursor() as cur:
                    query = "select * from {} where {} = %s".format(table, key)
                    cur.execute(query, (key_value,))
                    recs = cur.fetchall()
                    if len(recs):
                        if key in record:
                            del record[key]
                        values = list(record.values())
                        attrs_str = ", ".join("{} = %s".format(k) for k in record.keys())
                        query = "UPDATE {} SET {} WHERE {}=%s".format(table, attrs_str, key)
                        cur.execute(query, (*values, key_value))
                    else:
                        values = list(record.values())
                        stmt=self.insert_stmt(table, record)
                        cur.execute(stmt, values)
                    conn.commit()
                    return(cur.rowcount)
        except Exception as e:
            self.log.error(f"Stmt: {stmt}, values: {list(record.values())}, error: {e}")
            raise e


    def update_on_conflict(self, table, conflicting_cols: list=[], **record):
        """ insert record or updates all cols (excluded the
        conflicting ones) in case of conflict on a list of
        columns
        """
        return self.do_insert_or_update(table, conflicting_cols, record)


    def notify_channel(self, channel_name, payload):
        self.connection.set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)
        cursor = self.connection.cursor()
        cursor.execute("NOTIFY {}, '{}';".format(channel_name, json.dumps(payload)))


def encode_fields(d:dict) -> dict:
    for key in d.keys():
        if isinstance(d[key], dict):
            d[key] = json.dumps(d[key])
    return d

def encode_all(data):
    if isinstance(data, dict):
        return encode_fields(data)
    if isinstance(data, (list, tuple)):
        encoded = list()
        for item in data:
            encoded.append(json.dumps(item) if isinstance(item, (dict, list)) else item)
        return tuple(encoded)
